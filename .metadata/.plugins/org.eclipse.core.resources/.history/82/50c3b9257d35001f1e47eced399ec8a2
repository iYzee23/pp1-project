package rs.ac.bg.etf.pp1;

import org.apache.log4j.Logger;
import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.*;
import rs.etf.pp1.symboltable.structure.*;

public class SemanticAnalyzer extends VisitorAdaptor {
	
	Logger log = Logger.getLogger(getClass());
	
	public static final int NAMESPACE = 7;
	
	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" na liniji ").append(line);
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" na liniji ").append(line);
		log.info(msg.toString());
	}
	
	String currNamespace = "";
	Struct currType = null;
	Obj currClass = null;
	Obj currMethod = null;
	
	boolean returnFound = false;
	boolean errorDetected = false;
	
	// Program
	
	public void visit(ProgNamet progName) {
		progName.obj = Tabb.insert(Obj.Prog, progName.getProgName(), Tabb.noType);
		Tabb.openScope();
	}
	
	public void visit(Programt program) {
		Tabb.chainLocalSymbols(program.getProgName().obj);
		Tabb.closeScope();
		
		Obj mainObj = Tabb.find("main");
		if (mainObj == Tabb.noObj || mainObj.getKind() != Obj.Meth || mainObj.getType() != Tab.noType || mainObj.getLevel() != 0) {
			report_error("Method 'void main() { ...}' not found", program);
		}
	}
	
	// Namespace
	
	public void visit(NamespaceNamet namespaceName) {
		// we allow multiple declarations of namespace with same name
		Tabb.insert(NAMESPACE, namespaceName.getNamespaceName(), Tabb.noType);
		currNamespace = namespaceName.getNamespaceName() + "::";
	}
	
	public void visit(Namespacet namespace) {
		currNamespace = "";
	}
	
	// ConstDecl
	
	public void visit(ConstDeclt constDecl) {
		currType = null;
	}
	
	public void visit(ConstDeclSingle constDecl) {
		currType = constDecl.getType().struct;
	}
	
	public void visit(ConstPartNum constNum) {
		String constName = constNum.getConstName();
		Integer constValue = constNum.getConstValue();
		if (currType.getKind() != Struct.Int) {
			report_error("Incompatibile types for constant: " + typeYes.getNamespaceName(), typeYes);
			return;
		}
	}
	
	
	// VarDecl
	
	// ClassDecl
	
	// StaticInitializer
	
	// MethodDecl
	
	// FormPars
	
	// Type
	
	public void visit(TypeYes typeYes) {
		Obj namespaceObj = Tabb.find(typeYes.getNamespaceName());
		
		if (namespaceObj == Tabb.noObj || namespaceObj.getKind() != NAMESPACE) {
			report_error("Can't resolve namespace: " + typeYes.getNamespaceName(), typeYes);
		}
		
		String typeName = namespaceObj.getName() + "::" + typeYes.getTypeName();
		Obj typeObj = Tabb.find(typeName);
		typeYes.struct = typeObj.getType();
		
		if (typeObj == Tabb.noObj || typeObj.getKind() != Obj.Type) {
			report_error("Can't resolve type: " + typeYes.getTypeName(), typeYes);
		}
	}
	
	public void visit(TypeNo typeNo) {
		String typeName = currNamespace + typeNo.getTypeName();
		Obj typeObj = Tabb.find(typeName);
		typeNo.struct = typeObj.getType();
		
		if (typeObj == Tabb.noObj || typeObj.getKind() != Obj.Type) {
			report_error("Can't resolve type: " + typeNo.getTypeName(), typeNo);
		}
	}
	
	// Statement
	
	// DesignatorStatement
	
	// ActPars
	
	// Condition
	
	// CondTerm
	
	// CondFact
	
	// Expr
	
	// Term
	
	// Factor
	
	// Designator
	
	// Label
	
	// Assignop
	
	// Relop
	
	// Addop
	
	// Mulop
	

}
